---
title: "![](https://i.imgur.com/5EhpPqK.png) Producing dynamic reports"
date: "`r Sys.time()`"
subtitle: "Demonstration"
output:
  html_document:
    toc: no
    toc_depth: 2
    number_sections: no
    toc_float:
      collapsed: no
  word_document:
    toc: yes
    toc_depth: '2'
  pdf_document:
    toc: yes
    toc_depth: '2'
    pandoc_args: ["--extract-media", "."]
---
# Introduction{.tabset}
This is our dynamic report. The report will teach you how to make the report.

+ work through in order
+ ask questions if you get stuck
+ ask about how you might adapt this to suit your needs

## Getting set-up

### Starting an Rmarkdown document

There's a bit of preamble at the head of Rmarkdown documents that controls how they are built. For now, I'll suggest that you skip trying to figure it all out, and just use the header from this document. I'll give more details about setting up your Rmarkdown document at the end of this demo. 

### Knitting
We definitely don't want our end users to see our RMarkdown code. So the .Rmd file that you've been working on needs to be converted into a suitable output format. We call that conversion *knitting* (after the R package *knitr* that manages the conversion). To knit your file, you can either:

- select the Knit option from the menu at the top of the code pane. You can select any of the output formats, although I'd suggest sticking with HTML (webpage) while working through the demo. ![](https://i.imgur.com/HhM3NqK.png)
- alternatively, press ctrl+shift+k to knit to the last used format

The first time that you knit your document in RStudio Cloud, you may get a warning about required packages. Just agree - you'll need them to knit your document properly.
![](https://i.imgur.com/6pfFbXk.png)

### Getting R ready
Once you've got the header in place, we need to do a tiny bit of setting R up properly. 

```{r setup, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
  library(tidyverse)
  library(lubridate)
  library(NHSRplotthedots)
```

We load three packages (link to eventual NHS-R statement on tools and packages) here to help us do some useful work with our data. These are all *very* useful for health and care projects, so we'll briefly introduce them here:

+ [tidyverse](https://www.tidyverse.org/) - large ecosystem of tools designed for data science
+ [lubridate](https://lubridate.tidyverse.org/) - helps with handling dates and times
+ [NHSRplotthedots](https://github.com/nhs-r-community/NHSRplotthedots)  - NHS-R community tool for making XmR charts

You may need to install some or all of these packages. If you need to do this, you can add the line ```install.packages("PACKAGENAME")``` to your file, run that line (ctrl + enter), and then remove the line of code. Or install via ```Tools > Install packages...```.

Now that's working, we can skip ahead to the interesting part where we get start to work on our report..

## Using Rmarkdown

[Rmarkdown](http://rmarkdown.rstudio.com) is a simple markup language. You might have used it before without really knowing what it was called. If you've ever posted on a Wordpress site or web forum with basic text formatting options available, the chances are that you've already done at least a tiny bit of markdown. Just to give you an example, surrounding a word with asterisks - like ```*italics*``` formats it in *italics*. Pairs of asterisks either side of the word formats that word - like ```**bold``` - formats the text as **bold**. And so on. 

This kind of very basic formatting is known as Markdown. While it's simple, it's usually sufficient to allow the production of neat and clear documents that are easy to ready. Rmarkdown is just Markdown with a few extras to allow you to embed R code directly into the text that you're writing. That R code allows you to do more-or-less any data analysis that you might like and include the results in your markdown-formatted document. If this is all new to you, you might like to have a quick look at some of the excellent introductory R/Rmarkdown resources:

*italics*: ```*italics*```

**bold**: ```**bold**```

[links](https://google.com): ```[links](https://google.com)```

Heading levels

```
# Level 1
## Level 2
### Level 3
...

```

```![Linking images](https://i.imgur.com/5EhpPqK.png)```
![Linking images](https://i.imgur.com/5EhpPqK.png)

```
- dashes at the start of lines make bullet-points
- like so
```
- dashes at the start of lines make bullet-points
- like so

```
1. Numbers at the start of lines make numbered lists
2. like so
```
1. Numbers at the start of lines make numbered lists
2. Like so

Do have a look at the Rmarkdown in the code pane, and feel free to play around with it. Once you've had a look at some of the Rmarkdown in practice, we're ready to move on to get some data.

## Getting data

This ~~feels~~ is easy to do in practice. Instead of opening a data file directly (as we might when using Excel), and then inspecting and analysing it, we instead load all the data in that file into R. 

We load the data using the following command:

```{r get data, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
demo <- read_csv("demo.csv") 
```

+ ```read_csv``` is the function that opens the .csv data file
+ ```demo.csv``` is the path to our data file
+ ```<-``` assigns the data that read_csv pulls out of the file to...
+ ```demo``` - the tibble that contains our data

Explain chunks

Because there are lots of different types of data out there, there are lots of ways of loading data into R. ```read_csv``` is the most commonly-used one, because .csv files - **c**omma **s**eparated **v**alues - are widely used to share data. The other main function used to load data is tidyverse's ```read_excel```, which works similarly to ```read_csv```. 

Rather than explain how this works here, I'll encourage you to read the relevant manual pages, which you can do with the command ```?read_excel```. You can run this using ctrl+enter in RStudio.

At the end of this process, we can have a look at the first few rows of our data using the ```head()``` command:

```{r inspect data 1, echo=TRUE, eval=TRUE, warning = FALSE, message=FALSE}
head(demo)
```
This command shows us the first few rows of our data. From the .csv file, we have converted the data into a *tibble*, which is the name for the data structure used by the package ```tidyverse```. In this tibble (called ```demo```), each row contains four columns. One holds date, and the remaining three hold of counts of some imagined values from those dates. We can ask R to tell us other properties of the ```demo``` tibble too. For example, we can count the total number of rows with:

```{r inspect data 2, echo=TRUE, eval=TRUE, warning = FALSE, message=FALSE}
nrow(demo)
```

Or we can pull out the column headings with:

```{r inspect data 3, echo=TRUE, eval=TRUE, warning = FALSE, message=FALSE}
colnames(demo)
```
Note that in the couple of examples above, we've just asked R to show us the number of rows/column names. We can also save these findings, which we might do if we want to use them later for another purpose. Just for instance, we can make a new variable *demo_length* containing the number of rows in data with:

```{r inspect data 4, echo=TRUE, eval=TRUE, warning = FALSE, message=FALSE}
demo_length <- nrow(demo)
```

And we can refer back to the value of *demo_length* whenever we like:
```{r inspect data 5, echo=TRUE, eval=TRUE, warning = FALSE, message=FALSE}
demo_length
```

Or do things to that value - like multiplying it by five:
```{r inspect data 6, echo=TRUE, eval=TRUE, warning = FALSE, message=FALSE}
demo_length * 5
```

We can also create new variables from more complicated operations on our original tibble. For instance, we can extract a whole column using ```tibble$column```, and then add all the entries in that variable together using ```sum()```:

```{r inspect data 7, echo=TRUE, eval=TRUE, warning = FALSE, message=FALSE}
sum_count3 <- sum(demo$count3)
sum_count3
```
I think that's enough demonstrating for now. There's one an important problem with our tibble: our dates aren't proper dates yet. ```read_csv``` doesn't know that the values in the date column actually are dates. We can tell that by looking at the ```<<chr>>```, which stands for character in when we looked at ```head(demo)``` above. Character is the way that R refers to text values. But we definitely want those values to be stored properly as dates, and doing that conversion will be our next exercise.

## Cleaning data

Time for another R chunk:

```{r clean up data, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
demo <- demo %>% mutate(date = dmy(date))
```

There's a bit to unpack here. It makes most sense (to my mind, at least) to read this code backwards. From right to left, then:

+ ```dmy(date)```  is a lubridate command which takes whatever's in the bracket, and tries to convert it into a proper date. It works by assuming that it'll be a day value (d), followed by a month (m), followed by a year (y). There are also related commands like ```ymd()``` to be used when the dates given in our data are formatted differently.
+ ```mutate(date =...)``` takes the result of the ```dmy()``` above, and uses it in a tidyverse command ```mutate```. This is a really important and powerful tool, which makes new columns in tibbles from existing columns. Here, we tell ```mutate``` to make a new column called ```date``` by taking the result of the ```dmy(date)``` above.
+ ``` %>%``` [the pipe!](https://r4ds.had.co.nz/pipes.html) This is a way of chaining commands together. In this case, writing ```demo %>% mutate...``` tells R to take the demo tibble, and do the mutate command to it. The advantage here is that we can string ```%>%```s together, to do many operations in sequence on some set of data.
+ finally, we assign the modified demo tibble back on top of itself using ```<-```. Essentially, ```demo <- demo ...``` tells R to overwrite the starting version of demo with the updated version containing proper dates.

That simple exercise introduces several new concepts. **Question:** pause here? Explain again? Another exercise?

Now that we have some data loaded and cleaned up, we're ready to use it to start writing our report.

## Updating text

As a refresher, let's have a look at the first few rows of the demo tibble using ```head()```, and also print out the total number of rows using ```nrow(demo)```:

```{r update text 1, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
head(demo)
nrow(demo)
```

This data will change as the data in the demo.csv file changes. You can show yourself how this works as follows:

1. Knit this document now (menu at top middle of code pane or ctrl+shift+k)
2. Have a look at this section again - you should see that our original data has 68 rows
3. Now edit the demo.csv file. To do this, click on the demo.csv file in the `Files` pane, and select `View File`. This should open the data file in the code pane. 
4. Now delete a couple of rows of your choice, before saving and closing the file.
4. Now re-knit the document again. The data now has `r nrow(demo)` rows, rather than the original 68 rows.

### Some ways of getting data into your report

The raw R output that we've been using so far is useful, but looks pretty nasty. Ideally, we'd like to be able to format this text so that it fits into our report properly.

#### Inline text

We can include R variables and data inline in our text by wrapping an R command in backticks: `` `r '\x60r some_command()\x60'` ``. 

When I first started using R, I don't think that I'd ever used the backtick key - usually at the extreme top left of most keyboards, often below the `Escape` key. Backticks are definitely different from the apostrophe ('), and it's important to not get the two confused when you're working with R.

If you haven't already, do follow along with the source code - particularly to find out how the last few commands are managed.

<!-- And note that we can write comments in our RMarkdown file which won't be displayed. This one is here to advise you to ignore the horrible messing about with \x60r etc that I've done in the paragraph below to get backticks to display properly in RMarkdown. -->

For example, we can count up all of the rows here, and by using the expression `` `r '\x60r nrow(demo)\x60'` ``
find out that we have a total of `r nrow(demo)` rows in our tibble. Or by wrapping the command `sum(demo$count1)` we can add all the entries in the count1 column to give a total of `r sum(demo$count1)`. Or `max(demo$count3)` will let us discover that the maximum value in count3 is `r max(demo$count3)`. Or we can say that on the first day of this range (`r demo[1,1]`), the value of count2 was `r demo[1,3]`. Or that the mean (average) of count3 was `r round(mean(demo$count3), 1)`.

<!-- The square brackets in demo[1,3] allow us to pull out data from specified places in a tibble. The general syntax is [row,column]. -->

#### Using knitr

Sometimes our reports need to contain larger chunks of data than are comfortable to manage using inline text. The most obvious example is the data table. We have some R commands that are extremely helpful for writing data tables in reports. `knitr::kable` is the most useful of all, because it allows us to produce nicely formatted tables with the very minimum of fooling about. So the first few rows of our demo tibble look like this:

```{r data table 1, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
knitr::kable(head(demo))
```
I've included an example showing some of the other tweaks that might be useful to you with kable. I'd recommend having a look at ?kable to get a sense of the possible scope for tweaking tables in this way:

```{r data table 2, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
knitr::kable(head(demo))
```

I'll say it again: **change the data, and all this stuff will update automatically**. For example, you might like to include a date in your report describing which month the data is about. You can do this easily: the latest date in this data comes from `r month(max(demo$date), label=T, abbr=F)`. Change the data, re-knit the report, and bask in the glory of a updated report - go on, try it!

## Data processing
Most of the use that we get from data driven reports comes from the analysis that we do on the data. This is a very brief introduction to some basic analysis using R. We can do useful operations to our data like adding the columns together:

```{r processing 1, echo=FALSE, echo=TRUE, message=FALSE, warning=FALSE}
demo <- demo %>%
  mutate(total = count1 + count2 + count3) 

knitr::kable(head(demo))
```

Most of the details here should be familiar from previous parts. We use the pipe `>%>` to pass the `demo` tibble to `mutate`. `mutate` creates a new column (`total`) by adding together the three `count` columns, and we then reassign our updated tibble to `demo`. That's then displayed nicely by `knitr::kable`.

We can also summarise tables of data:

```{r processing 2, echo=FALSE, echo=TRUE, message=FALSE, warning=FALSE}
knitr::kable(demo %>% summarise(across(where(is.numeric), ~round(mean(.x, na.rm=T)))))
```

That's a little bit harder to read, but breaks down nicely:

- we find the average of columns using `mean(.x, na.rm=T)`. The `.x` tells R to use whatever data is passed from the previous command, while the `na.rm=T` part tells R to ignore any missing data.
- `~round()` just rounds the mean values to the nearest whole number
- `across(where(is.numeric)` tells R that we want to use all the columns (so work `across()` all the columns) that contain numbers (`where(is.numeric)`)
- `summarise()` - crunch the results down into a single row
- `demo %>%` take the data in the demo tibble
- finally, `knitr::kable` displays a nice table containing the results

We can also add some extra instructions to `kable` to re-name the columns in our table to keep things clear for the reader of our report:

```{r processing 3, echo=FALSE, echo=TRUE, message=FALSE, warning=FALSE}
knitr::kable(demo %>% summarise(across(where(is.numeric), ~round(mean(.x, na.rm=T)))), col.names = c("Mean of count 1", "Mean of count 2", "Mean of count 3", "Mean of total"))
```

We've added the line `col.names = c("Mean of count 1", "Mean of count 2", "Mean of count 3", "Mean of total")` just before the last bracket from the previous command. This tells kable to rename our table's columns to read properly.

**Question here about depth** Many many other kinds of data processing are possible, it's what R was built for. I worry though that this is getting too involved for an introductory session. Would like feedback - might consider breaking into a separate training resource here??

## Drawing graphs{.tabset}
Graphs are a really important part of report writing. There are lots of ways of drawing graphs in R, but the three that we'll demonstrate here are:

- a widely-used general purpose graph package called `ggplot2` for most common types of graph (bar, column, line, scatter...)
- an NHS-specific package called `NHSplotthedots` for producing XmR/run charts
- a diagram-drawing package called `DiagrammeR` which we'll use to draw a dynamic flowchart

### ggplot2 introduction
Let's start with a minimal example using our demo tibble:

```{r graph 1, echo=TRUE, message=FALSE, warning=FALSE}

ggplot(demo) +
  geom_point(aes(x=count1, y=count2))

```

Here, the code works as follows:

- `ggplot(demo)` - we tell ggplot2 to use the demo tibble as a data source
- `geom_point` tells ggplot2 that we want an XY scatter plot
- the crux of the code is the `(aes(x=count1, y=count2))`. This tells R which columns in the demo tibble it should use to plot the points specified in `geom_point`
- finally, the `+` then chains together commands to produce a single plot

There are lots and lots of other `geom_xxx` options. A couple of commonly-used examples are geom_col and geom_line:

```{r, echo=TRUE, message=FALSE, warning=FALSE}

ggplot(demo) +
  geom_col(aes(x=count1, y=count2))

```
```{r, echo=TRUE, message=FALSE, warning=FALSE}

ggplot(demo) +
  geom_line(aes(x=count1, y=count2))

```

We can also add, using `+` other elements to ggplot2 graphs. Going back to our first XY scatter, we can add labels and regression lines as follows:

```{r graph 2, echo=TRUE, message=FALSE, warning=FALSE}

ggplot(demo) +
  geom_point(aes(x=count1, y=count2)) +
  geom_smooth(aes(x=count1, y=count2), method='lm') +
  labs(title="Scatter plot of count 1 against count 2 with linear regression") +
  ylab("Count 2") +
  xlab("Count 1")
```

### more advanced ggplot2
The secret to most useful visualisations is to get the data into the right format. Here's an example, based on using `dplyr` from the tidyverse to select parts of the data (i.e. excluding the total column), and then reformatting the demo tibble data. This allows ggplot2 to then plot counts for each day, using the `fill` option to set each type of count as a different colour.

```{r graph 3, echo=TRUE, message=FALSE, warning=FALSE}

demo %>%
  dplyr::select(!total) %>%
  pivot_longer(!date, names_to = "names", values_to = "count") %>%
  ggplot() +
  geom_col(aes(x=date, y=count, fill=names)) +
  labs(title = "Stacked bar of counts by date", fill="Count type") +
  xlab("Date") +
  ylab("Count")
```

### NHSplot the dots
(to add - or possibly not given the size of this thing)

### DiagrammeR
This is an interesting example of a very different kind of dynamic graph. Here, the structure of the graph remains the same, but the numerical counts will update as the data changes.

```{r graph 4, echo=TRUE, message=FALSE, warning=FALSE}
DiagrammeR::grViz("
digraph graph2 {

// a graph statement, which applies to the whole graph
graph [layout = dot]

// node statements, which describe how each of the nodes work. Note the @@x - corresponding to substituted label text below
node [shape = rectangle, width = 4, style = filled, fillcolor = beige]
a [label = '@@1']
b [label = '@@2']
c [label = '@@3']
d [label = '@@4']

// edge statements, which describe how each of the nodes are connected
a -> d
b -> d
c -> d

}

# Outside the main grViz bracket, the footnote-style substituted label text. [x] provides the text for @@x above.
[1]: paste0('Count 1 total (sum = ', sum(demo$count1), ')')
[2]: paste0('Count 2 total (sum = ', sum(demo$count2), ')')
[3]: paste0('Count 3 total (sum = ', sum(demo$count3), ')')
[4]: paste0('Total (sum = ', sum(demo$total), ')')
")

```

## More details

### Rmarkdown document settings

The easiest option is to start a new Rmarkdown document direct from the RStudio menu `File >> New file >> R Markdown...`. Alternatively, you can copy the header from this document, and paste it at the top of your document. Everything between the pair of three dashes: `---` is concerned with setting up this Rmarkdown document:

```{verbatim}
---
title: "![](https://i.imgur.com/5EhpPqK.png) Dynamic report demo"
date: "`r Sys.time()`"
output:
  html_document:
    toc: no
    toc_depth: 2
    number_sections: no
    toc_float:
      collapsed: no
  pdf_document:
    toc: yes
    toc_depth: '2'
    pandoc_args: ["--extract-media", "."]
  word_document:
    toc: yes
    toc_depth: '2'
---
```
You might notice that there are a couple of differences between the header from this document and the default version that RStudio gives you. I've added a link to the KIND Learning Network banner image as part of the title. If you're thinking about adapting this report to suit your purposes, you can easily change both of those by editing the URL (and the title text) in the following line:

```{verbatim}
title: "![](https://i.imgur.com/5EhpPqK.png) Dynamic report demo"
```

More info on [YAML editing in chapter 2 of the excellent R Markdown Cookbook](https://bookdown.org/yihui/rmarkdown-cookbook/rmarkdown-anatomy.html).

Most of this header block is made up of options for the different output formats (html, word, and pdf). In RStudio, you can select which output format you'd like your report to be rendered as:

![](https://i.imgur.com/HhM3NqK.png)
Try these out now - this demo report should knit to each of the three formats without any problems. I'd recommend sticking with html while you're working on a report, though, just because it tends to render most quickly, and plays nicely with other aspects of the workflow while you're writing.

One thing to watch out for when tweaking these options: indentation and white-space matters. Each of the three output formats (html_document, pdf_document, and word_document) are indented from the *output:* line, and each of the output format options are indented too. A common cause of documents not knitting (see below) are small errors in the indenting in the header.

You might notice another tweak that I've made to the pdf output options for this document, which is to add the line:
```{verbatim}
    pandoc_args: ["--extract-media", "."]
```


### So what's next?

#### Alternatives
In the R/Rmarkdown universe, [Flexdashboard](https://pkgs.rstudio.com/flexdashboard/) looks great: there's an [example](https://www.themillerlab.io/post/flexdashboards/mcc_fake_cohort_dashboard_for_post.html#outcomes-by-stage) and a  [walkthrough by the Miller Lab](https://www.themillerlab.io/post/flexdashboards/)

### More on R code chunks

Code chunks in Rmarkdown start and end with a triple backtick:

![](https://i.imgur.com/o419Vw6.png)

There are then a few options that you can set for the code chunk. Here:

+ r: telling Rmarkdown to interpret this code as R. There are other languages that you can use in Rmarkdown, which is one of the strengths of building reports in this way.
+ setup: the chunk label. This can be anything you like, but no duplicates are allowed. Very useful for navigation in more complicated reports
+ echo=TRUE: whether to show this code in the report. If this is set to FALSE, you'll just see the output of the code (more on this below)
+ eval=TRUE: whether or not to run the code. If eval=FALSE, the code won't do anything other than appear in the report (useful if you're explaining how something works - like this report!)
+ warning = FALSE: whether to show warnings in the report if something goes wrong with your code
+ message=FALSE: whether to show information messages about how your code is running

Lots more info in the [Rmarkdown Cookbook](https://bookdown.org/yihui/rmarkdown/r-code.html)

you can also use `knitr::opts_chunk$set`, which is a really powerful way of managing chunk options - but that's a bit beyond the scope of this demo.